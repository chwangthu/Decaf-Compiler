\relax 
\@writefile{toc}{\contentsline {section}{\numberline {1}本阶段工作}{1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.1}错误恢复}{1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.2}新特性的LL(1)文法}{1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.3}运行截图}{2}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces S1+\relax }}{2}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces S1-\relax }}{3}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Decaf语言由于允许if语句的else分支为空，因此不是严格的 LL(1)语言，但是我 们的工具依然可以处理这种冲突。请根据工具所生成的预测分析表中if语句相关项的预测 集合先做猜测，并对照工具wiki，理解本工具的处理方法。请在实验报告中说明此方法的原理，并举一个具有这种冲突的Decaf语言程序片段，说明它哪里有冲突以及如何解决。}{3}}
\@writefile{toc}{\contentsline {section}{\numberline {3}为什么把原先的数组comprehension表达式文法Expr ::= [Expr for identifier in Expr <if BoolExpr>] | ...改写为LL(1)比较困难?􏰀}{5}}
\@writefile{toc}{\contentsline {section}{\numberline {4}无论何种错误处理方法，都无法完全避免误报的问题。请举出一个语法错误的Decaf程序例子，用你实现的Parser进行语法分析会带来误报。根据你用的错误处理方法，这些误报为什么会产生?}{6}}
